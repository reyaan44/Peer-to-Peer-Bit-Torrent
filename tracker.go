package main

import (
	"encoding/binary"
	"encoding/hex"
	"fmt"
	"math/rand"
	"net"
	"net/url"
	"time"

	gotorrentparser "github.com/j-muller/go-torrent-parser"
)

func buildConnRequest() []byte {

	buff := make([]byte, 16)

	// First 8 bytes (magic constant)
	binary.BigEndian.PutUint64(buff[:8], 0x41727101980)

	// next 4 bytes will be 0 (denting connect request)
	binary.BigEndian.PutUint32(buff[8:12], 0)

	// next 4 bytes will be a random number generated by us, which is a Transaction Id.
	rand.Seed(time.Now().UnixNano())
	trId := generateRandomBytes(4)
	copy(buff[12:], trId[:])

	return buff
}

func parseConnResponse(buff []byte) ConnResp {

	// Creating an object for the struct
	obj := new(ConnResp)

	// First 4 bytes are for action (0 for Connect)
	obj.action = binary.BigEndian.Uint32(buff[:4])

	// Next 4 bytes are for the transaction_id (Random number we sent)
	obj.transaction_id = binary.BigEndian.Uint32(buff[4:8])

	// Next 8 bytes are the Connection Id
	obj.connId = binary.BigEndian.Uint64(buff[8:])

	return *obj
}

func buildAnnounceRequest(connectionId uint64, Torrent *gotorrentparser.Torrent) []byte {

	buff := make([]byte, 98)

	// Adding connection ID from 1->8
	binary.BigEndian.PutUint64(buff[:8], connectionId)

	// Adding action from 9->12
	binary.BigEndian.PutUint32(buff[8:12], 1)

	// next 4 bytes 13->16 will be a random number generated by us, which is a Transaction Id.
	rand.Seed(time.Now().UnixNano())
	trId := generateRandomBytes(4)
	copy(buff[12:16], trId[:])

	// Adding InfoHash 20 byte string
	infoHash, _ := hex.DecodeString(Torrent.InfoHash)
	copy(buff[16:36], infoHash[:])

	// Adding PeerId 20 byte string
	copy(buff[36:56], myPeerId[:])

	// download

	// left

	// uploaded

	// event

	// ip address

	// key (A random number of 4 bytes as an identifier of each UDP request)
	key := generateRandomBytes(4)
	copy(buff[88:92], key[:])

	// num_want (Total peers wanted, can be [0,100], If -1, its the server's choice)
	binary.BigEndian.PutUint32(buff[92:96], 100)

	// port
	binary.BigEndian.PutUint16(buff[96:], 6881)

	return buff
}

func parseAnnounceRequest(buff []byte, n int) AnnResp {

	// Making an object of Announce Response
	obj := new(AnnResp)

	// 1->4 for action
	obj.action = binary.BigEndian.Uint32(buff[:4])

	// 4->8 for transaction id
	obj.transaction_id = binary.BigEndian.Uint32(buff[4:8])

	// 8->12 for interval
	obj.interval = binary.BigEndian.Uint32(buff[8:12])

	// 12->16 for leechers
	obj.leechers = binary.BigEndian.Uint32(buff[12:16])

	// 16->20 for seeders
	obj.seeders = binary.BigEndian.Uint32(buff[16:20])

	// 20->... First 4, Ip, next 2, Port
	for i := 20; i < n; i += 6 {
		peerObj := new(Peer)
		peerObj.IP = binary.BigEndian.Uint32(buff[i : i+4])
		peerObj.Port = binary.BigEndian.Uint16(buff[i+4 : i+6])
		obj.PeerList = append(obj.PeerList, *peerObj)
	}

	return *obj
}

func sendConnectionRequest(buff []byte, Torrent *gotorrentparser.Torrent, peers *[]Peer, current int) {

	// Parsing the Announce of the Torrent in URL
	URL, err := url.Parse(Torrent.Announce[current])
	if err != nil {
		fmt.Println(err)
		return
	}

	// Establishing a connection by sending a UDP request packet
	fmt.Println(URL.Host)
	connection, err := net.Dial("udp", URL.Host)
	if err != nil {
		fmt.Println(err)
		return
	}
	defer connection.Close()

	// Waiting for 15 seconds for the response
	err = connection.SetReadDeadline(time.Now().Add(5 * time.Second))
	if err != nil {
		fmt.Println(err)
		return
	}

	// Sending the Connection Request Packet
	connection.Write(buff)

	// Reading the Connection
	recieved := make([]byte, 16)
	total_bytes, err := connection.Read(recieved)

	if err != nil {
		fmt.Println(err)
		return
	}
	if total_bytes < 16 {
		fmt.Println("Recieved Bytes in Connection Response is not 16")
		return
	}
	// Checking for Transaction ID
	response_conn := parseConnResponse(recieved)
	if response_conn.transaction_id != binary.BigEndian.Uint32(buff[12:]) {
		panic("Transaction ID not same")
	}

	if response_conn.action == 0 {

		announceBuff := buildAnnounceRequest(response_conn.connId, Torrent)
		// Sending the connection the Announce Packet
		connection.Write(announceBuff)
		// Getting the response
		recieved := make([]byte, 1024)
		no_of_bytes, err := connection.Read(recieved)

		if err != nil {
			fmt.Println(err)
			return
		}
		if no_of_bytes < 20 {
			fmt.Println("Total Bytes smaller than 20 in Announce Response")
			return
		}
		// Parsing the Recieved Data
		response_ann := parseAnnounceRequest(recieved, no_of_bytes)
		fmt.Println(response_ann.seeders, response_ann.leechers)
		// Check for Transaction ID
		if response_ann.transaction_id != binary.BigEndian.Uint32(announceBuff[12:16]) {
			panic("Announce Response Transaction ID not same")
		}
		// Check for action
		if response_ann.action != 1 {
			fmt.Println("Announce Response Action not 1")
		}
		// ... is used when we append a slice to another slice
		*peers = append(*peers, response_ann.PeerList...)

	} else {
		fmt.Println("Response Action is not for Connection")
		return
	}
}

func getUniquePeersList(peersList []Peer) []Peer {

	obj := []Peer{}

	// making a map to find distinct values
	freq := map[Peer]bool{}

	for _, i := range peersList {
		freq[i] = true
	}

	for i := range freq {
		obj = append(obj, i)
	}

	return obj
}

func getPeersList(Torrent *gotorrentparser.Torrent) []Peer {

	// Making a list of objects for storing Peers
	peersList := []Peer{}

	// Building the connection Request
	buff := buildConnRequest()

	// Sending the Connection Request to get the Peers List
	for pos := range Torrent.Announce {
		if Torrent.Announce[pos][0:3] == "udp" {
			fmt.Println("Tracker Number = ", pos)
			sendConnectionRequest(buff, Torrent, &peersList, pos)
		}
	}

	peersList = getUniquePeersList(peersList)

	return peersList
}
