package main

import (
	"encoding/binary"
	"encoding/hex"
	"math/rand"
	"time"

	gotorrentparser "github.com/j-muller/go-torrent-parser"
)

/*
1. Connection Request
2. Announce Request
3. Handshake Request
4. Keep Alive Message
5. Choke Message
6. Unchoke Message
7. Interested Message
8. Not Interested Message
9. Have Message
10. Bitfield Message
11. Request Block Message
12. Send Piece Message
13. Cancel Block Message
14. Port Message
*/

func buildConnRequest() []byte {

	buff := make([]byte, 16)

	// First 8 bytes (magic constant)
	binary.BigEndian.PutUint64(buff[:8], 0x41727101980)

	// next 4 bytes will be 0 (denoting connect request)
	binary.BigEndian.PutUint32(buff[8:12], 0)

	// next 4 bytes will be a random number generated by us, which is a Transaction Id.
	rand.Seed(time.Now().UnixNano())
	trId := generateRandomBytes(4)
	copy(buff[12:], trId[:])

	return buff
}

func buildAnnounceRequest(connectionId uint64, Torrent *gotorrentparser.Torrent) []byte {

	buff := make([]byte, 98)

	// Adding connection ID from 1->8
	binary.BigEndian.PutUint64(buff[:8], connectionId)

	// Adding action from 9->12
	binary.BigEndian.PutUint32(buff[8:12], 1)

	// next 4 bytes 13->16 will be a random number generated by us, which is a Transaction Id.
	rand.Seed(time.Now().UnixNano())
	trId := generateRandomBytes(4)
	copy(buff[12:16], trId[:])

	// Adding InfoHash 20 byte string
	infoHash, _ := hex.DecodeString(Torrent.InfoHash)
	copy(buff[16:36], infoHash[:])

	// Adding PeerId 20 byte string
	copy(buff[36:56], myPeerId[:])

	// download

	// left

	// uploaded

	// event

	// ip address

	// key (A random number of 4 bytes as an identifier of each UDP request)
	key := generateRandomBytes(4)
	copy(buff[88:92], key[:])

	// num_want (Total peers wanted, can be [0,100], If -1, its the server's choice)
	binary.BigEndian.PutUint32(buff[92:96], 100)

	// port
	binary.BigEndian.PutUint16(buff[96:], 6881)

	return buff
}

func buildHandshake(Torrent *gotorrentparser.Torrent) []byte {

	buff := make([]byte, 68)

	// pstr len
	copy(buff[0:], []byte{19})

	// pstr
	copy(buff[1:20], []byte("BitTorrent protocol"))

	// reserved
	binary.BigEndian.PutUint64(buff[20:28], 0)

	// info_hash
	infoHash, _ := hex.DecodeString(Torrent.InfoHash)
	copy(buff[28:48], infoHash[:])

	// peer_id
	copy(buff[48:68], myPeerId[:])

	return buff
}

func buildKeepAlive() []byte {

	// len = 0
	buff := make([]byte, 4)

	binary.BigEndian.PutUint32(buff, 0)

	return buff
}

func buildChoke() []byte {

	// len = 1, id = 0
	buff := make([]byte, 5)

	binary.BigEndian.PutUint32(buff[:4], 1)

	copy(buff[4:5], []byte{0})

	return buff
}

func buildUnchoke() []byte {

	// len = 1, id = 1
	buff := make([]byte, 5)

	binary.BigEndian.PutUint32(buff[:4], 1)

	copy(buff[4:5], []byte{1})

	return buff
}

func buildInterested() []byte {

	// len = 1, id = 2
	buff := make([]byte, 5)

	binary.BigEndian.PutUint32(buff[:4], 1)

	copy(buff[4:5], []byte{2})

	return buff
}

func buildNotInterested() []byte {

	// len = 1, id = 3
	buff := make([]byte, 5)

	binary.BigEndian.PutUint32(buff[:4], 1)

	copy(buff[4:5], []byte{3})

	return buff
}

func buildHave(pieceIndex uint32) []byte {

	// len = 5, id = 4, piece index
	buff := make([]byte, 9)

	binary.BigEndian.PutUint32(buff[:4], 5)

	copy(buff[4:5], []byte{4})

	binary.BigEndian.PutUint32(buff[5:], pieceIndex)

	return buff
}

func buildBitfield(bitfield []bool) []byte {

	// len = 1 + len(bitfield), id = 5, bitfield

	newLen := (len(bitfield) + 7) / 8

	buff := make([]byte, 5+newLen)

	binary.BigEndian.PutUint32(buff[:4], uint32(1+newLen))

	copy(buff[4:5], []byte{5})

	for i := range myBitfield {
		if myBitfield[i] == true {
			buff[5+i/8] |= 1 << (7 - uint(i%8))
		}
	}

	return buff
}

func buildRequestBlock(pieceIndex uint32, length uint32, begin uint32) []byte {

	// len = 13, id = 6, piece index, begin, length
	buff := make([]byte, 17)

	binary.BigEndian.PutUint32(buff[:4], 13)

	copy(buff[4:5], []byte{6})

	binary.BigEndian.PutUint32(buff[5:9], pieceIndex)

	binary.BigEndian.PutUint32(buff[9:13], begin)

	binary.BigEndian.PutUint32(buff[13:17], length)

	return buff
}

func buildPiecetoSend(pieceIndex uint32, begin uint32, block []byte) []byte {

	// len = 9 + len(block), id = 7, piece index, begin, block
	buff := make([]byte, 13+len(block))

	binary.BigEndian.PutUint32(buff[:4], uint32(9+len(block)))

	copy(buff[4:5], []byte{7})

	binary.BigEndian.PutUint32(buff[5:], pieceIndex)

	binary.BigEndian.PutUint32(buff[9:], begin)

	copy(buff[13:], block[:])

	return buff
}

func buildCanceltoSend(pieceIndex uint32, begin uint32, length uint32) []byte {

	// len = 13, id = 8, piece index, begin, length
	buff := make([]byte, 13)

	binary.BigEndian.PutUint32(buff[:4], uint32(13))

	copy(buff[4:5], []byte{8})

	binary.BigEndian.PutUint32(buff[5:], pieceIndex)

	binary.BigEndian.PutUint32(buff[9:], begin)

	binary.BigEndian.PutUint32(buff[13:], length)

	return buff
}

func buildPort(port uint16) []byte {

	// len = 3, id = 9, port
	buff := make([]byte, 7)

	binary.BigEndian.PutUint32(buff[:4], 3)

	copy(buff[4:5], []byte{9})

	binary.BigEndian.PutUint16(buff[5:], port)

	return buff
}
